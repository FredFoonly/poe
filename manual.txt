
                                POE Manual


                             K. Michael Parker
                               Apr 20, 2015



     POE is a text editor in the IBM family of editors.  Unlike many other 
programmer's editors, it is intended to be a fast and lightweight editor, 
in this respect it shares the spirit of MicroEmacs and BSD vi more than 
than GNU Emacs or VIM.  The most direct inspiration for POE was a 
1980's-era editor for DOS called Personal Editor (aka PE), which that was 
written by an IBM employee named Jim Wylie and made available under their 
Employee Software program.  

     Characteristics of the IBM style of editor includes screen-based 
addressing of the text buffer, multiple types of text selections, 
prominent use of the command line, and folding of text lines based on 
filter criteria such as indentation level or presence of search terms.  
Some of these characteristics survive in a few scattered editors whose 
lineage derives from the IBM editors (SlickEdit is one example), and a few 
of them have been emulated to some degree by other modern editors.  VIM 
has some concept of folding, for example, and GNU Emacs supports some 
rectangular commands.  But these are generally implemented awkwardly and 
in an inconsistent manner.  

     Cartesian addressing is one of the most pervasive characteristics 
distinguishing IBM style editors.  Most text editors or word processors 
handle addressing starting from the character the cursor is on, and from 
there calculate which row and column the cursor should be displayed at.  
Cartesian addressing reverses this, it treats the row and column of the 
cursor position as primary values, and from there calculates which 
position in the buffer should be affected by the editor command.  This 
seems like a difference without a distinction, but in fact the difference 
is immediately obvious - editors with buffer positioning will only allow 
the cursor to be positioned on text; if the cursor is at the end of a line 
then when the cursor is moved up or down you will see the cursor move to 
the end of the lines.  An editor with cartesian addressing allows the 
cursor to be moved freely around the screen, including moving it beyond 
the end of the text.  So when you move the cursor up or down with the 
cursor key, it means the cursor simply moves up or down without drama 
instead of also jumping left and right to follow the end of the line.  

     A side-effect of this is that cartesian editors tend to treat tabs as 
a compression technique; the editor itself uses only spaces.  Sequences of 
spaces are converted to tabs when the file is saved to disk, and tabs are 
converted to the appropriate number of spaces when the file is read in.  

     The command line orientation derives from the IBM mainframe, where 
interactive editing came fairly late in the game.  All editing commands 
are available from the command line, including trivial ones such as moving 
the cursor around, inserting and deleting text, etc.  Other programmers 
editors also support this feature for a similar reason.  The various 
versions of Emacs are probably the most comparable, though vi and its 
clones also offer a somewhat less-capabile command line interface.   

     Marking text is another distinctive area where IBM style editors 
differ from the current practice.  IBM style editors typically support at 
least three types of marked areas:  marking one or more lines, marking a 
rectangular region, and marking character sequences.  This latter type 
(character sequence) is usually the only mark type supported by word 
processors and most programming editors.  There are a number of useful 
operations that only make sense on line or rectangle marks, and these are 
rarely supported well (or at all) on editors without these special types 
of marks.

     Text line folding is another characteristic of IBM style editors. 
They usually support a command like "ALL" which takes a search term and 
shows the lines that contain the search term; some also contain a command 
"NONE" which shows the lines that don't contain the search term.  Other 
commands hide lines that are indented beyond a certain level.

     One other IBM-style feature that is not supported by POE is the use 
of REXX as a macro language, much like GNU Emacs uses ELisp or Epsilon 
uses EEL.  There are other IBM-style editors available that implement this 
feature.  The editor THE (The Hessling Editor) is an extremely powerful 
and complete example.  However, POE does have an extremely quick and 
easy-to-use way to customize the keyboard, binding any key to any sequence 
of editing commands, either interactively or via a pre-written profile 
file.  While not nearly as powerful as REXX or elisp, it is much simpler 
and practical for everyday use.  POE's key definition language is based on 
the one in PE2.  

     Both style of editor are perfectly usable; my standard editor for many 
years was Epsilon, an Emacs-style editor supporting almost none of the IBM 
editor features.  It is simply a matter of the editor's personality 
lending itself to a certain feel or flow in the editing process.  However, 
IBM style editors do seem to have a natural affinity for languages with 
significant whitespace.  In the 80's PE and it's descendant PE2 were popular
editors among Fortran and Assembly programmers, and it's possible that the 
relative disappearance of this type of editor is due to the disappearance 
of that style of programming language on DOS and Windows.

     Ironically, whitespace-sensitive languages made a comeback on Unix 
platforms - Python, for example, is sensitive to whitespace, as is 
Haskell, and newer languages like Nim (aka Nimrod) and F# incorporate 
whitespace into their syntax.  Python and Haskell date to the late 
80's/early 90's, but their popularity was mostly on Unix platforms which 
had no inexpensive IBM-style editors until the late 90's when THE came 
out.  But THE is too focused on compabitility with the IBM mainframe 
editors like SPF and XEDIT; while these editors immensely powerful 
(comparable to GNU Emacs), they are just a bit too odd for people who have 
no mainframe experience to draw on, requiring mastery of not only a new 
editor but also a new programming language (Rexx).  



==============================
Basic Usage/Quick Start
==============================

     Enter "poe" from the command line to enter the editor.

     The Escape key toggles you between the command line and the data area.

     Useful commands are:

     "qquit" to quit the editor, 

     "edit <filename>" to edit a new file,

     "save" to save a file,

     "file" to save and close the file,

     "quit" to close the current file, possibly abandoning changes.  If 
all of the files are closed, the editor exits.  

     F2 is a shortcut for "save".

     F3 is a shortcut for "file".  

     F4 is a shortcut for "quit".

     C-S splits the editing window.  Repeatedly pressing C-S cycles 
through the various window schemes.  C-Z ("zoom") will maximise the 
current window.  

     Arrow keys move you around, along with page up and page down.  Home 
and end work as expected etc.  C-Home moves you to the top of the file, 
C-End moves you to the bottom of the file.  The Insert key toggles between 
insert and replace modes.  

     From the command line, a forward slash is used to search.  For 
example, "/foo/" will search forward from the cursor position for the text 
"foo".  There are a variety of options available, for example "/foo/-" 
will search backwards from the cursor position, while "/foo/o" will search 
from the top of the file.  For brevity, the trailing slash may be omitted 
if there are no search options.  Replacement is similar, "c/foo/bar/" will 
search forwards for the next occurrence of "foo" and replace it with 
"bar".  More information on searching and replacing is available in the 
manual under the LOCATE and CHANGE commands.  

     Alt-C begins a character mark, another Alt-C marks the end of the 
region, or extends the region if it already exists.  Alt-D deletes the 
region, Alt-M moves it, and Alt-Z copies it.  Marked regions are globally 
visible - you can mark a region in one file, switch to another file and 
press Alt-Z to copy the text over.  Alt-L is used for line marks, and 
Alt-B for block marks.  


===============================
Default Key Bindings
===============================

     The following key descriptions are based on the definitions in the 
default POE profile file.  


-------------------------------
Cursor Movement Keys
-------------------------------

UP 

     The Up key moves the cursor up one line towards the top of the file.  

     def up=[up 1] 



DOWN 

     Move the cursor down one line.  

     def down=[down 1] 



LEFT 

     Move the cursor down one line.  

     def left=[left 1] 



RIGHT 

     Move the cursor down one line.  

     def right=[right 1] 



PGUP 

     Move the cursor up by the number of lines on the screen, adjusting 
     the viewport to keep the line roughly centered in the window.  

     def pgup=[page up 1] 



PGDN 

     Move the cursor down by the number of lines on the screen, adjusting 
     the viewport to keep the line roughly centered in the window.  

     def pgdn=[page down 1] 



HOME

     Move the cursor to the beginning of the line.  

     def home=[begin line] 



END

     Move the cursor to the end of the line.  

     def end=[end line] 



ESC

     Toggles the cursor between the command line and the data area.  

     def esc=[command toggle] 



TAB

     Moves the cursor to the next tab stop.  

     def tab=[tab] 



S-TAB

     Moves the cursor to start of the previous word.  

     def s-tab=[backtab word] 



C-LEFT

     Moves the cursor to start of the previous word.  

     def c-left=[backtab word] 



C-RIGHT

     Moves the cursor to the next word.  

     def c-right=[tab word] 



C-UP

     Moves the cursor up 20 lines.  

     def c-up=[up 20] 



C-DOWN

     Moves the cursor down 20 lines.  

     def c-down=[down 20] 



C-PGDN

     Moves the cursor to the bottom edge of the window.  

     def c-pgdn=[top edge] 



C-PGUP

     Moves the cursor to the top edge of the window.  

     def c-pgup=[top edge] 



C-HOME

     Moves the cursor to the top of the file.  

     def c-home=[top] 



C-END

     Moves the cursor to the bottom line of the file.  

     def c-end=[bottom] 



C-A

     Moves the cursor to the start of the line.  

     def c-a=[begin line] 



C-E

     Moves the cursor to the end of the line.  

     def c-e=[end line] 



A-Y

     Moves the cursor to the beginning of the current marked region.  If 
     the current mark is a line mark then the cursor moves to the top line 
     of the marked area, but stays in the same column.  If it is a 
     character mark or block mark then the cursor moves to the upper left 
     corner of the mark.  

     def a-y=[begin mark] 



A-E

     Moves the cursor to the end of the marked area.  If the current mark 
     is a line mark then the cursor moves to the bottom line of the marked 
     area but stays in the same column.  If it is a character mark or 
     block mark then the cursor moves to the upper left corner of the mark.  

     def a-e=[end mark] 



A-LEFT

     Moves the cursor left 40 characters.  

     def a-left=[left 40] 



A-RIGHT

     Moves the cursor right 40 characters.  

     def a-right=[right 40] 



A-UP

     Moves the cursor up 20 lines.  

     def a-up=[up 20] 



A-DOWN

     Moves the cursor down 20 lines.  

     def a-down=[down 20] 
     


-------------------------------
Editing Keys
-------------------------------

INSERT

     Toggles between insert and overstrike modes.  

     def insert=[insert toggle] 



DEL

     Deletes the character underneath the cursor.  

     def del=[delete char] 



ENTER

     Inserts a new line underneath the current line, and indent the cursor 
     underneath the previous line.  

     def enter=[insert line] [push mark] [mark line] [backtab word]\ 
               [begin line] [begin word] [begin mark] [pop mark] 



BACKSPACE

     Deletes the character before the cursor.  If the cursor is in column 
     1, then it deletes the character underneath the cursor.  

     def backspace=[rubout] 



F5

     Deletes the current line and positions the cursor at the start of the 
     line.  

     def f5=[begin line] [erase end line] 



F6

     Deletes from the cursor to the end of the current line.  

     def f6=[erase end line] 



F9

     Inserts a blank line beneath the current line.  The cursor position 
     does not change.  

     def f9=[insert line] 



F10

     Inserts a blank line beneath the current line, and moves the cursor 
     to the new line aligned underneath the start of the previous line.  

     def f10=[insert line] [push mark] [mark line] [backtab word]\ [begin 
     line] [begin word] [begin mark] [pop mark] 



C-C

     Centers the current line between the margins.  

     def c-c=[push mark] [mark line] [center in margins] [unmark] [pop mark] 



C-F

     Inserts a copy of the command line beneath the current line.  

     def c-f=[copy from command] 



C-K

     Delete from the cursor to the end of the line.  

     def c-k=[erase end line] 



C-L

     Refresh the screen, and center the current line in the center of the 
     window.  

     def c-l=[resize display] [center line] 



C-N

     Move the cursor down 60 lines.  

     def c-n=[down 60] 



C-R

     Duplicate the current line.  

     def c-r=[push mark] [mark line] [copy mark] [pop mark] 



C-T

     Copy the current line to the command line.  

     def c-t=[copy to command] 



C-F1
C-F2
C-F3
C-F4
C-F5
C-F6
C-F7
C-F8
C-F9
C-F10

     Inserts 1-10 lines after the current line.  

     def c-f1=[insert line 1]
     ...
     def c-f10=[insert line 10] 




S-F3

     Reformats the current marked area.  The marked region must be a line 
     mark.  

     def s-f3=[reflow]



S-F7

     Shifts the marked region left 1 space.  

     def s-f7=[shift left] 



S-F8

     Shifts the marked region right 1 space.  

     def s-f8=[shift right] 



A-B

     Starts/Extends a block mark.  

     def a-b=[mark block] 



A-C

     Starts/Extends a character mark.  

     def a-c=[mark char] 



A-D

     Delete the marked area.  

     def a-d=[begin mark] [delete mark] 



A-F

     Fills the marked area with a character supplied from the keyboard.  

     def a-f=[fill mark] 



A-J

     Joins the current line with the next line.  

     def c-h=[push mark] [down] [first nonblank] [mark block] [end line] \
             [end word] [mark block] [up] [end line] [end word] [right 2] \
             [copy mark] [down] [unmark] [delete line] [up] [pop mark]



A-L

     Starts/Extends a line mark.  

     def a-l=[mark line] 



A-M

     Moves the marked area to the cursor position.  If the mark is a line 
     region then the text will be inserted beneath the current line.  If 
     it is a block region then the text will be shifted right to provide 
     space.  

     def a-m=[move mark] 



A-O

     Overlays the marked region to the cursor position.  

     def a-o=[overlay block] 



A-P

     Reformat the paragraph starting at the current line, then moves the 
     cursor to the start of the next paragraph.  

     def a-p=[cursor data] [push mark] [mark line] [find blank line] [up]\
             [mark line] [reflow] [end mark] [down] [tab word] [pop mark] 



A-S

     Split the current line at the cursor position.  

     def a-s=[split] 



A-U

     Destroy the mark.  This removes the hilighting, and allows the user 
     to place a new mark in a new location or a new mark type.  

     def a-u=[unmark] 



-------------------------------
Miscellaneous Keys 
-------------------------------

C-S

     Splits the screen into two or more windows.  Pressing C-S once will 
     split the screen horizontally.  Pressing it a second time will split 
     the screen into four panes - one in each quadrant.  Pressing it a 
     third time will split the window vertically.  Pressing it a fourth 
     time will return the screen to a single window.  

     def c-s=[split screen] 



C-W

     Cycle to the next window on the screen.  

     def c-w=[next window] 



C-V

     Cycle to the next view of the current file.  

     def c-v=[next view] 



C-Z

     Zoom to the current window by closing all the other windows.  

     def c-z=[zoom window] 



C-SPACE

     Execute the command line.  

     def c-space=[execute] 



F8

     Cycle the current window to the next file in the ring.  

     def f8=[next file] 



S-LEFT

     Decrease the position of the vertical splitter by 2%.  

     def s-left=[decr vsplit 2] 



S-RIGHT

     Increase the position of the vertical splitter by 2%.  

     def s-right=[incr vsplit 2] 



S-UP

     Decrease the position of the horizontal splitter by 2%.  

     def s-up=[decr hsplit 2] 



S-DOWN

     Increase the position of the horizontal splitter by 2%.  

     def s-down=[incr hsplit 2] 



===============================
Commands
===============================

?

     The ? family of commands displays a variety of information about the 
     editor's configuration.  The information is placed on the command 
     line, in a format suitable for execution.  This allows you to edit 
     the command line and press <enter> to modify POE's configuration.  


? BLANKCOMPRESS

     Usage: ? BLANKCOMPRESS

     Indicates whether blank compression during save is enabled.  The 
     default is ON.  



? HSPLIT

     Usage:  ? HSPLIT

     Displays the position of the horizontal splitter used in multi-window 
     operation, as a percentage between 1 and 100.  The default is 50.  



? KEY

     Usage:  ? KEY <keyname> 

     Displays the definition of the specified key.  



? MARGINS

     Usage:  ? MARGINS

     Displays the left, right, and paragraph margins.  The default is 1 
     256 1.  



? SEARCHCASE

     Usage: ? SEARCHCASE

     Displays the setting for case-sensitivity in the locate and change 
     commands.  



? TABEXPAND

     Usage:  ? TABEXPAND

     Indicates whether tab expansion during load is enabled.  The default 
     is ON.  



? TABEXPAND SIZE

     Usage:  ? TABEXPAND SIZE

     Displays the number of spaces used for compressing/decompressing 
     tabs.  The default is 8.  



? TABS

     Usage:  ? TABS

     Displays the tab stops.  The default is 1 6 11 16 ...  



? VSPLIT

     Usage:  ? VSPLIT

     Displays the position of the vertical splitter used in multi- window 
     operation.  The number is a percentage between 1 and 100.  



? WRAP
     
     Usage:  ? WRAP

     Displays whether automatic word wrapping is enabled.  The default is 
     ON.  



BACKTAB 

     Usage:  BACKTAB

     Moves the cursor to the preceeding tab stop, or column 1 if there are 
     no preceeding tab stops.



BACKTAB WORD

     Usage:  BACKTAB WORD

     Moves the cursor to the first character of the preceeding word, 
     moving to an earlier line if necessary.  A word in this context is a 
     group of characters separated by blanks.



BEGIN LINE

     Usage:  BEGIN LINE

     Moves the cursor to the first column in the current line.  If the 
     cursor is already in the first column, then BEGIN LINE does nothing.



BEGIN MARK

     Usage:  BEGIN MARK

     Moves the cursor to the beginning of the marked area.

     For Block and Character marks, the BEGIN MARK command moves the 
     cursor to the top line of the marked area, and to the leftmost marked 
     column of that line.  For Line marks, the BEGIN MARK command moves 
     the cursor to the top line without changing its column.

     The mark does not have to be in the file you are currently viewing.  
     If it is in a different file, then that file will be made current 
     and the cursor moved to the appropriate location.  

     One use for BEGIN MARK or END MARK is as a quick bookmark.  Place a 
     mark in a file, then whenever you want to come back then press the 
     key that BEGIN MARK is assigned to, to jump back to that file and 
     location.  



BEGIN WORD

     Usage:  BEGIN WORD

     Moves the cursor to the beginning of the current word.  If the cursor 
     is between words, then the cursor will be moved to the beginning of 
     the next word.  



BOTTOM
     Usage: BOTTOM

     Moves the cursor to the last line of the current file.  The cursor 
     column position is not affected.


 
BOTTOM EDGE

     Usage: BOTTOM EDGE

     Moves the cursor to the last row of the current text area.



CENTER IN MARGINS

     Usage:  CENTER IN MARGINS

     Using the marked area (which must be a line mark), centers each line 
     between the margins.  If the line is longer than the inter-margin 
     space, then the line will be positioned at the left margin.



CENTER LINE

     Usage:  CENTER LINE

     Adjusts the display so the line with the cursor is in the middle of 
     the screen.  



CHANGE

     Usage:  [change|c] /pattern/replacement/[-e*mn] 
       
     The CHANGE command replaces a character or string of characters with 
     another string.  You can replace only one or multiple occurrences, 
     and can restrict the replacement to only the marked region.  For 
     brevity it can be abbreviated as simply C, and the space between the 
     C and the delimiter can be omitted.  

     The delimiter character '/' can be any symbol.  The command 

          c/foo/bar/
          
     is equivalent to 

          c~foo~bar~


     Options:  

          '-' Search backwards.
          'e' Exact search (case sensitive)
          '*' Replace multiple occurrences.
          'm' Replace only marked occurrences.
          'n' Replace only unmarked occurrences.
          'o' Search from the end of the file (top or bottom).

     Case sensitivity is controlled by a variety of factors.  The SET 
     SEARCHCASE option determines the default mode.  This can be 
     overridden with the 'e' option which forces case sensitivity.  

     The replacement text is always used with its exact case.  


CHR

     Usage:  CHR <c>

     Inserts the character at the current position, or overwrites the 
     character if the POE is in overstrike mode.



CLEAR MARKS

     Usage:  CLEAR MARKS

     Removes all marks from the mark stack.



COLUMN

     Usage:  COLUMN <n>

     Moves the cursor to column <n>.  The cursor line is not affected.



COMMAND TOGGLE

     Usage:  COMMAND TOGGLE

     If the cursor is in the text area, it moves to the command area.  If 
     it was in the command area, it will be moved to the text area.
     


CONFIRM CHANGE

     Usage:  CONFIRM CHANGE

     Confirms any pending operation that requires user confirmation, such 
     as CHANGE and QUIT.  In any other situation, this command does nothing.



COPY MARK

     Usage:  COPY MARK

     Copies the marked area to the cursor's location, leaving the original 
     marked area intact.

     For Line marks, the copy will be inserted below the cursor line.

     For Character marks, the copy will be inserted at the cursor 
     location; the text to the right of the cursor location will be 
     shifted down and right as needed.  

     For Block marks, the copy will be inserted starting at the cursor 
     line and column.  The text on each line will be shifted right to 
     accommodate the new text.



CURSOR COMMAND

     Usage:  CURSOR COMMAND

     Moves the cursor to the command line.



CURSOR DATA

     Usage:  CURSOR DATA

     Moves the cursor to the text area.


 
DECR HSPLIT

     Usage:  DECR HSPLIT <n>

     Shifts the horizontal splitter up by <n> percent.



DECR VSPLIT

     Usage:  DECR VSPLIT <n>

     Shifts the vertical splitter left by <n> percent.



DEFINE

     Usage:  DEF <key> = [ <command> ]...

     The equals sign is required.  The key name can be any valid key name, 
     such as A (for the letter 'a'), S-A (upper case version of the letter 
     'a'), S-UP, C-PGUP, etc.  The definition may only span one line, 
     though the line-continuation character '\' can be used in profile 
     files.  All keys in POE are defined in this manner, even the standard 
     keys like the letter and number keys.  

     The case of the key name and commands is not significant.  

     The valid commands are the commands listed in this document.  They 
     are delimited with '[' and ']' characters.

     You may use single quotes (') around literal characters.  You may use 
     double quotes (") around strings.  

     You can remove the definition for a key by defining it to no 
     commands, e.g.  

         def f1=



DELETE CHAR

     Usage:  DELETE CHAR

     Deletes the character under the cursor and shifts the remaining 
     characters one position left.  This is similar to the RUBOUT command.  
    


DELETE LINE

     Usage:  DELETE LINE

     Deletes the line the cursor is on and shifts the rest of the text up 
     one line.  The cursor does not move.

     If there is only one line in the file, then that line is erased but 
     not deleted.  



DELETE MARK

     Usage:  DELETE MARK

     Deletes the text within the marked area and removes the mark.

     For Line marks, each marked line is deleted and the remaining lines 
     moved up.

     For Character marks, lines marked in their entirety are erased.  The 
     marked text at the end of the first marked line and the beginning of 
     the last marked line are erased, and first and last lines are joined 
     together.  

     For Block marks, the marked area on each line is deleted, shifting 
     the text to the right of the block over to the leftmost marked column.



DOWN 

     Usage:  DOWN [<n>]

     Moves the cursor n rows towards the bottom of the file.  If the 
     cursor is on the last line then this command does nothing.  The 
     default value for <n> is 1.



EDIT

     Usage:  EDIT [<filename> [tabs|notabs]]
     Synonym: E

     Edits a file.  If no filename is given, the editor cycles to the next 
     file in the edit ring.

     If the file is already loaded in the editor, the editor switches to 
     that file.

     If the file has not been loaded, then it is loaded into memory, the 
     tabs are expanded, and the editor switches its view to that file.

     The tabs option disables tab expansion, the notabs option forces tab 
     expansion, independent of the value of the SET TABEXPAND option. 



END LINE

     Usage: END LINE

     Moves the cursor to the position after the last character on the 
     current line.  

     If the cursor is already at the end of the line, this command does 
     nothing.  If it is beyond the last character on the line, the cursor 
     is moved backwards to the position after the last character.  If the 
     line is blank, the cursor is moved to the start of the line.



END MARK

     Usage:  END MARK

     Moves the cursor to the end of the marked area.  For Line marks, the 
     cursor moves to the last line of the marked area, but the column 
     position does not change.  For Block and Character marks, the cursor 
     moves to the exact character in the lower right corner of the marked 
     area.  

     See also: BEGIN MARK



END WORD

     Usage:  END WORD 

     Moves the cursor to the end of the current word.  If the cursor is 
     between words, the cursor is moved to the end of the preceeding word, which
     may be on another line.



ERASE BEGIN LINE 

     Usage: ERASE BEGIN LINE

     Erases the characters from the cursor to the start of the current line, shifting
     the remaining characters to the left.  The cursor moves to the start 
     of the line.



ERASE COMMAND LINE

     Usage:  ERASE COMMAND LINE

     Erases the command line.  The cursor does not move.



ERASE END LINE

     Usage:  ERASE END LINE

     Erases characters from the cursor to the end of the current line.  
     The cursor does not move.



ESCAPE

     Usage:  ESCAPE [<n>]

     Inserts (or overstrikes) the character with the specified ASCII code. 
     If no code is specified, the user can enter a 3-digit decimal number 
     from the keyboard to specify the code interactively.  

     (The interactive part is not yet implemented)



EXECUTE

     Usage: EXECUTE

     Performs the command currently on the command line, even if the 
     cursor is not on the command line.  This is useful for executing 
     dynamically-generated commands, or for re-executing CHANGE and LOCATE 
     commands, which do not clear the command line after they have run.  
     Bind a key to EXECUTE (C-SPACE by default) and you can easily re-run 
     the most recent CHANGE or LOCATE.  



FILE

     Usage:  FILE [<filename> [tabs|notabs]]

     Writes the current file to disk and removes it from memory.  If you 
     only specify FILE with no filename or other options, the file is 
     saved under it's current name and removed from memory.  If you 
     specify a filename then the file is written to that filename before 
     being removed from memory.  The tabs/notabs option overrides the 
     default tab compression setting.  

     You cannot use the FILE command on an internal file such as 
     ".unnamed", ".keys", or ".dir".  



FILL MARK

     Usage:  FILL MARK [<char>]

     Fills a marked area with a character.  If the character is not part 
     of the FILL MARK command, the user will be prompted to enter the 
     character from the keyboard.  

     See also: MARK BLOCK, MARK CHAR, and MARK LINE.



FIND BLANK LINE 

     Usage:  FIND BLANK LINE

     Searches forward for a blank line.  If the cursor is already on a 
     blank line, the cursor does not move.  

     When using POE for word processing, each paragraph should be 
     separated by blank lines.  The default key definition for 
     reformatting paragraphs uses this command to find the end of the 
     paragraph.  


FIND PREV BLANK LINE

     Usage:  FIND PREV BLANK LINE

     Searches backwards for a blank line.  If the cursor is already on a 
     blank line, the cursor does not move.



FIRST NONBLANK

     Usage: FIRST NONBLANK

     Moves the cursor to the first character of the current line that is 
     not a blank.  If there are no nonblank characters on the line, the 
     cursor is moved to the beginning of the line.



INCR HSPLIT

     Usage:  INCR HSPLIT <n>

     Adjusts the position of the horizontal splitter downwards by the 
     specified percent.



INCR VSPLIT

     Usage: INCR VSPLIT <n>

     Adjusts the position of the vertical splitter rightwards by the 
     specified percent.



INDENT 

     Usage:  INDENT

     Moves the cursor to the paragraph margin if the cursor is on the 
     first line, or the preceeding line is blank.  Otherwise the cursor 
     moves to the left margin.  This is helpful when word processing if 
     you define the Enter key to the command sequence [insert line] 
     [indent].  



INSERT LINE

     Usage:  INSERT LINE

     Inserts a new line below the current line, shifting the rest of the 
     lines down.  The cursor moves to the first column of the new line.

     To insert a line above the current line, move up then insert the 
     line.  To insert a line above line 1, move to the start of the first 
     line, and use the SPLIT command.



INSERT MODE

     Usage:  INSERT MODE

     Sets the input mode to insert.  In insert mode, typing new characters 
     results in the character under the cursor being shifted over before 
     the new character is placed in the file.  The current input mode is 
     displayed on the status line to the right of the line and column 
     numbers.  



INSERT TOGGLE

     Usage:  INSERT TOGGLE

     Switches the input mode between insert and replace.



JOIN

     Usage:  JOIN

     Concatenates the current line and the next one, and deletes the next line.
     The cursor may be anywhere on the current line, and does not move 
     after connecting the two.  This command does nothing if the current 
     line is the last line in the file.

     See also: SPLIT



LEFT 

     Usage:  LEFT [<n>]

     Moves the cursor <n> positions left.  The default value for <n> is 1. 
     When the cursor hits column 1 the LEFT command does nothing.  



LEFT EDGE

     Usage:  LEFT EDGE

     Moves the cursor to the 




LEFT WRAP



LINE


LOCATE

Usage: [locate|l|] /pattern/[-seo]
       
The LOCATE command searches for a string of characters.  For brevity 
it can be abbreviated as simply L, and the space between the L and 
the delimiter can be omitted.  If the delimiter '/' is used, the 
command name can be omitted completely.

The delimiter character '/' can be any symbol.  The commands

     /foo/
     l!foo!
     locate ~foo~

are all equivalent.

Options:

     '-' Search backwards.
     's' Select the found text with a character mark.
     'e' Exact search (case sensitive)
     'o' Search from the end of the file (top or bottom).

Case sensitivity is controlled by a variety of factors.  The SET 
SEARCHCASE option determines the default mode.  This can be 
overridden with the 'e' option which forces case sensitivity.
Usage: locate /pattern/replacement/[-e*mn]



LOWERCASE

MARK BLOCK
MARK CHAR
MARK LINE
MOVE MARK
MOVE VIEW DOWN
MOVE VIEW LEFT
MOVE VIEW RIGHT
MOVE VIEW UP

NAME
NEXT FILE
NEXT VIEW
NEXT WINDOW

OVERLAY BLOCK

PAGE DOWN
PAGE UP
POP MARK
PUSH MARK

QQUIT 
QUIT

REPLACE MODE
REDRAW
REFLOW
RESIZE DISPLAY
RIGHT EDGE
RIGHT WRAP
RIGHT 
RUBOUT JOIN
RUBOUT 

S
SAVE
SET BLANKCOMPRESS
SET HSPLIT
SET MARGINS


SET SEARCHCASE

Usage: SET SEARCHCASE [ANY|EXACT|SMART]

ANY means that searches are case-insensitive by default.

EXACT means that searches are case-sensitive by default.

If the SMART option is used, then searches will be case-sensitive 
if there are any upper-case characters in the search pattern; if 
there are no upper-case characters in the search pattern then 
case-insensitive search will be used.



SET TABEXPAND
SET TABEXPAND SIZE
SET TABS
SET VSPLIT
SET WRAP
SHIFT LEFT
SHIFT RIGHT
STR 
SPLIT SCREEN
SPLIT

TAB WORD
TAB 
TRIM LEADING
TRIM TRAILING
TRIM
TOP EDGE
TOP

UNMARK
UP
UPPERCASE

ZOOM WINDOW
